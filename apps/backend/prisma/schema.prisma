generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String         @id @default(cuid())
  name             String
  email            String         @unique
  image            String?
  passwordHash     String
  createdAt        DateTime       @default(now())
  
  // Privacy fields
  deletedAt        DateTime?
  anonymized       Boolean        @default(false)
  anonName         String?        // e.g., "Deleted User"
  anonAvatarUrl    String?        // optional generic avatar
  
  paidExpenses     Expense[]      @relation("ExpensePayer")
  expenseSplits    ExpenseSplit[]
  expensePayers    ExpensePayer[]
  groupMemberships GroupMember[]
  settlementsFrom  Settlement[]   @relation("SettlementFrom")
  settlementsTo    Settlement[]   @relation("SettlementTo")
  notificationPref NotificationPref?
  passwordResetTokens PasswordResetToken[]
  friendsAsUser       Friend[]        @relation("UserFriends")
  friendsAsFriend     Friend[]        @relation("FriendOf")
}

model Group {
  id          String        @id @default(cuid())
  name        String
  currency    String
  createdBy   String
  createdAt   DateTime      @default(now())
  expenses    Expense[]
  members     GroupMember[]
  settlements Settlement[]
  invites     Invite[]
  recurringExpenses RecurringExpense[]

  @@index([createdAt, id])
}

model GroupMember {
  id       String   @id @default(cuid())
  groupId  String
  userId   String
  role     String
  joinedAt DateTime @default(now())
  group    Group    @relation(fields: [groupId], references: [id])
  user     User     @relation(fields: [userId], references: [id])

  @@unique([groupId, userId])
}

model Expense {
  id          String         @id @default(cuid())
  groupId     String
  paidById    String
  amountCents Int
  currency    String
  note        String?
  date        DateTime       @default(now())
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  group       Group          @relation(fields: [groupId], references: [id])
  paidBy      User           @relation("ExpensePayer", fields: [paidById], references: [id])
  splits      ExpenseSplit[]
  payers      ExpensePayer[] // New relation for multiple payers

  @@index([groupId, createdAt, id])
}

model ExpenseSplit {
  id           String @id @default(cuid())
  expenseId    String
  userId       String
  amountCents  Int
  expense      Expense @relation(fields: [expenseId], references: [id])
  user         User    @relation(fields: [userId], references: [id])

  @@unique([expenseId, userId])
}

model ExpensePayer {
  id           String @id @default(cuid())
  expenseId    String
  userId       String
  amountCents  Int
  expense      Expense @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  user         User    @relation(fields: [userId], references: [id])

  @@unique([expenseId, userId])
}

model Settlement {
  id          String   @id @default(cuid())
  groupId     String
  fromUserId  String
  toUserId    String
  amountCents Int
  currency    String
  note        String?
  date        DateTime @default(now())
  createdAt   DateTime @default(now())
  group       Group    @relation(fields: [groupId], references: [id])
  fromUser    User     @relation("SettlementFrom", fields: [fromUserId], references: [id])
  toUser      User     @relation("SettlementTo", fields: [toUserId], references: [id])

  @@index([groupId, createdAt, id])
}

model Invite {
  id        String   @id @default(cuid())
  groupId   String
  email     String
  token     String   @unique
  role      String
  createdAt DateTime @default(now())
  usedAt    DateTime?
  group     Group    @relation(fields: [groupId], references: [id])
}

model RecurringExpense {
  id            String   @id @default(cuid())
  groupId       String
  paidById      String
  amountCents   Int
  currency      String
  note          String?
  cron          String
  beneficiaries Json?
  active        Boolean  @default(true)
  createdAt     DateTime @default(now())
  group         Group    @relation(fields: [groupId], references: [id])
}

model FxRate {
  id        String   @id @default(cuid())
  date      DateTime
  baseCcy   String
  quoteCcy  String
  rate      Decimal  @db.Decimal(10, 6)
  createdAt DateTime @default(now())
  
  @@unique([date, baseCcy, quoteCcy])
  @@index([date])
}

model NotificationPref {
  userId String @id
  email  Boolean @default(true)
  push   Boolean @default(true)
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model IdempotencyKey {
  id            String   @id @default(cuid())
  // Client-provided header value: Idempotency-Key
  key           String
  // Scope to ensure uniqueness where it matters (e.g., per user + route)
  scope         String   // e.g., `user:<userId>|path:<method> <route>`
  method        String
  path          String

  // Deterministic fingerprint of the request body that matters
  bodyHash      String

  // Persisted response to return on subsequent identical requests
  statusCode    Int
  responseBody  Bytes    // raw JSON bytes (buffer)

  // Execution markers
  inProgress    Boolean  @default(false) // optimistic in-flight lock
  createdAt     DateTime @default(now())
  expiresAt     DateTime // TTL (e.g., now + 24h)

  @@unique([key, scope]) // the main uniqueness guarantee
  @@index([scope, createdAt])
  @@index([expiresAt])
}

model GroupBalance {
  groupId      String
  userId       String
  balanceCents BigInt   @default(0) // Postgres BIGINT

  updatedAt    DateTime @updatedAt

  @@id([groupId, userId])
  @@index([groupId])
}

model Activity {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())

  groupId    String
  actorId    String?        // user who did it (null for system jobs)
  type       String         // "expense.create" | "expense.update" | "expense.delete" | "settlement.create" | "invite.accept" | "recurring.run" | "file.upload" | ...
  targetType String?        // "expense" | "settlement" | "invite" | "file"
  targetId   String?        // id of the entity

  // Keep small, useful, REDACTED information (never store secrets)
  data       Json

  @@index([groupId, createdAt, id])  // for pagination
  @@index([actorId, createdAt])
}

model AuditLog {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())

  actorUserId   String?  // null for system
  groupId       String?  // scope when action is within a group
  action        String   // e.g., "auth.login", "group.create", "expense.create", "settlement.create", "invite.accept"
  targetType    String?  // e.g., "group","expense","settlement","user","file"
  targetId      String?  // e.g., entity id

  ip            String?
  userAgent     String?

  // Arbitrary metadata; store redacted DTO or useful bits
  meta          Json

  // Optional tamper-evidence: running hash of previous + current
  prevHash      String?
  chainHash     String?

  @@index([groupId, createdAt, id])
  @@index([actorUserId, createdAt, id])
  @@index([createdAt, id])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([token])
  @@index([expiresAt])
}

model Friend {
  id        String   @id @default(cuid())
  userId    String   // The user who added the friend
  friendId  String   // The friend being added
  token     String   @unique // Token for friend to accept
  status    String   @default("pending") // pending, accepted, declined
  createdAt DateTime @default(now())
  acceptedAt DateTime?
  
  user   User @relation("UserFriends", fields: [userId], references: [id], onDelete: Cascade)
  friend User @relation("FriendOf", fields: [friendId], references: [id], onDelete: Cascade)
  
  @@index([token])
  @@index([status])
}
